









Start¬†Here



 Learn Python


 Python Tutorials ‚ÜíIn-depth articles and tutorials
 Video Courses ‚ÜíStep-by-step video lessons
 Quizzes ‚ÜíCheck your learning progress
 Learning Paths ‚ÜíGuided study plans for accelerated learning
 Community ‚ÜíLearn with other Pythonistas
 Topics ‚ÜíFocus on a specific area or skill level
 Unlock All Content




Store


 RP Membership
Python Basics Book
Python Tricks Book
CPython Internals Book
The Real Python Course
Managing Python Dependencies
Sublime Text + Python Setup
Pythonic Wallpapers Pack
Python Mugs, T-Shirts, and More
Pythonista Cafe Community
Browse All ¬ª




More


Python Newsletter
Python Podcast
Python Job Board
Meet the Team
Become a Tutorial Author
Become a Video Instructor






 Search












Join


Sign‚ÄëIn







Start¬†Here



 Learn Python


 Python Tutorials ‚ÜíIn-depth articles and tutorials
 Video Courses ‚ÜíStep-by-step video lessons
 Quizzes ‚ÜíCheck your learning progress
 Learning Paths ‚ÜíGuided study plans for accelerated learning
 Community ‚ÜíLearn with other Pythonistas
 Topics ‚ÜíFocus on a specific area or skill level
 Unlock All Content




Store


 RP Membership
Python Basics Book
Python Tricks Book
CPython Internals Book
The Real Python Course
Managing Python Dependencies
Sublime Text + Python Setup
Pythonic Wallpapers Pack
Python Mugs, T-Shirts, and More
Pythonista Cafe Community
Browse All ¬ª




More


Python Newsletter
Python Podcast
Python Job Board
Meet the Team
Become a Tutorial Author
Become a Video Instructor






 Search












Join


Sign‚ÄëIn




 Python Tutorials ‚ÜíIn-depth articles and tutorials
 Video Courses ‚ÜíStep-by-step video lessons
 Quizzes ‚ÜíCheck your learning progress
 Learning Paths ‚ÜíGuided study plans for accelerated learning
 Community ‚ÜíLearn with other Pythonistas
 Topics ‚ÜíFocus on a specific area or skill level
 Unlock All Content


 RP Membership
Python Basics Book
Python Tricks Book
CPython Internals Book
The Real Python Course
Managing Python Dependencies
Sublime Text + Python Setup
Pythonic Wallpapers Pack
Python Mugs, T-Shirts, and More
Pythonista Cafe Community
Browse All ¬ª


Python Newsletter
Python Podcast
Python Job Board
Meet the Team
Become a Tutorial Author
Become a Video Instructor




 Search












üò∑ Stuck at home? Enjoy free courses, on¬†us¬†‚Üí



üò∑ Stuck at home? Enjoy free courses, on¬†us¬†‚Üí







Python sleep(): How to Add Time Delays to Your Code

by Mike Driscoll


intermediate
python


Mark as Completed




Tweet
Share
Email






Table of Contents


Adding a Python sleep() Call With time.sleep()
Adding a Python sleep() Call With Decorators
Adding a Python sleep() Call With Threads
Using time.sleep()
Using Event.wait()


Adding a Python sleep() Call With Async IO
Adding a Python sleep() Call With GUIs
Sleeping in Tkinter
Sleeping in wxPython


Conclusion








   Remove ads

Have you ever needed to make your Python program wait for something? Most of the time, you‚Äôd want your code to execute as quickly as possible. But there are times when letting your code sleep for a while is actually in your best interest.
For example, you might use a Python sleep() call to simulate a delay in your program. Perhaps you need to wait for a file to upload or download, or for a graphic to load or be drawn to the screen. You might even need to pause between calls to a web API, or between queries to a database. Adding Python sleep() calls to your program can help in each of these cases, and many more!
In this tutorial, you‚Äôll learn how to add Python sleep() calls with:

time.sleep()
Decorators
Threads
Async IO
Graphical User Interfaces

This article is intended for intermediate developers who are looking to grow their knowledge of Python. If that sounds like you, then let‚Äôs get started!
Free Bonus: Get our free "The Power of Python Decorators" guide that shows you 3 advanced decorator patterns and techniques you can use to write to cleaner and more Pythonic programs.
  Remove adsAdding a Python sleep() Call With time.sleep()
Python has built-in support for putting your program to sleep. The time module has a function sleep() that you can use to suspend execution of the calling thread for however many seconds you specify.
Here‚Äôs an example of how to use time.sleep():
>>>>>> import time
>>> time.sleep(3) # Sleep for 3 seconds

If you run this code in your console, then you should experience a delay before you can enter a new statement in the REPL.

Note: In Python 3.5, the core developers changed the behavior of time.sleep() slightly. The new Python sleep() system call will last at least the number of seconds you‚Äôve specified, even if the sleep is interrupted by a signal. This does not apply if the signal itself raises an exception, however.

You can test how long the sleep lasts by using Python‚Äôs timeit module:
$ python3 -m timeit -n 3 "import time; time.sleep(3)"
3 loops, best of 3: 3 sec per loop

Here, you run the timeit module with the -n parameter, which tells timeit how many times to run the statement that follows. You can see that timeit ran the statement 3 times and that the best run time was 3 seconds, which is what was expected.
The default number of times that timeit will run your code is one million. If you were to run the above code with the default -n, then at 3 seconds per iteration, your terminal would hang for approximately 34 days! The timeit module has several other command line options that you can check out in its documentation.
Let‚Äôs create something a bit more realistic. A system administrator needs to know when one of their websites goes down. You want to be able to check the website‚Äôs status code regularly, but you can‚Äôt query the web server constantly or it will affect performance. One way to do this check is to use a Python sleep() system call:
import time
import urllib.request
import urllib.error

def uptime_bot(url):
    while True:
        try:
            conn = urllib.request.urlopen(url)
        except urllib.error.HTTPError as e:
            # Email admin / log
            print(f'HTTPError: {e.code} for {url}')
        except urllib.error.URLError as e:
            # Email admin / log
            print(f'URLError: {e.code} for {url}')
        else:
            # Website is up
            print(f'{url} is up')
        time.sleep(60)

if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)

Here you create uptime_bot(), which takes a URL as its argument. The function then attempts to open that URL with urllib. If there‚Äôs an HTTPError or URLError, then the program catches it and prints out the error. (In a live environment, you would log the error and probably send out an email to the webmaster or system administrator.)
If no errors occur, then your code prints out that all is well. Regardless of what happens, your program will sleep for 60 seconds. This means that you only access the website once every minute. The URL used in this example is bad, so it will output the following to your console once every minute:
HTTPError: 404 for http://www.google.com/py

Go ahead and update the code to use a known good URL, like http://www.google.com. Then you can re-run it to see it work successfully. You can also try to update the code to send an email or log the errors. For more information on how to do this, check out Sending Emails With Python and Logging in Python.
Adding a Python sleep() Call With Decorators
There are times when you need to retry a function that has failed. One popular use case for this is when you need to retry a file download because the server was busy. You usually won‚Äôt want to make a request to the server too often, so adding a Python sleep() call between each request is desirable.
Another use case that I‚Äôve personally experienced is where I need to check the state of a user interface during an automated test. The user interface might load faster or slower than usual, depending on the computer I‚Äôm running the test on. This can change what‚Äôs on the screen at the moment my program is verifying something.
In this case, I can tell the program to sleep for a moment and then recheck things a second or two later. This can mean the difference between a passing and failing test.
You can use a decorator to add a Python sleep() system call in either of these cases. If you‚Äôre not familiar with decorators, or if you‚Äôd like to brush up on them, then check out Primer on Python Decorators. Let‚Äôs look at an example:
import time
import urllib.request
import urllib.error

def sleep(timeout, retry=3):
    def the_real_decorator(function):
        def wrapper(*args, **kwargs):
            retries = 0
            while retries < retry:
                try:
                    value = function(*args, **kwargs)
                    if value is None:
                        return
                except:
                    print(f'Sleeping for {timeout} seconds')
                    time.sleep(timeout)
                    retries += 1
        return wrapper
    return the_real_decorator

sleep() is your decorator. It accepts a timeout value and the number of times it should retry, which defaults to 3. Inside sleep() is another function, the_real_decorator(), which accepts the decorated function.
Finally, the innermost function wrapper() accepts the arguments and keyword arguments that you pass to the decorated function. This is where the magic happens! You use a while loop to retry calling the function. If there‚Äôs an exception, then you call time.sleep(), increment the retries counter, and try running the function again.
Now rewrite uptime_bot() to use your new decorator:
@sleep(3)
def uptime_bot(url):
    try:
        conn = urllib.request.urlopen(url)
    except urllib.error.HTTPError as e:
        # Email admin / log
        print(f'HTTPError: {e.code} for {url}')
        # Re-raise the exception for the decorator
        raise urllib.error.HTTPError
    except urllib.error.URLError as e:
        # Email admin / log
        print(f'URLError: {e.code} for {url}')
        # Re-raise the exception for the decorator
        raise urllib.error.URLError
    else:
        # Website is up
        print(f'{url} is up')

if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)

Here, you decorate uptime_bot() with a sleep() of 3 seconds. You‚Äôve also removed the original while loop, as well as the old call to sleep(60). The decorator now takes care of this.
One other change you‚Äôve made is to add a raise inside of the exception handling blocks. This is so that the decorator will work properly. You could write the decorator to handle these errors, but since these exceptions only apply to urllib, you might be better off keeping the decorator the way it is. That way, it will work with a wider variety of functions.

Note: If you‚Äôd like to brush up on exception handling in Python, then check out Python Exceptions: An Introduction.

There are a few improvements that you could make to your decorator. If it runs out of retries and still fails, then you could have it re-raise the last error. The decorator will also wait 3 seconds after the last failure, which might be something you don‚Äôt want to happen. Feel free to try these out as an exercise!
  Remove adsAdding a Python sleep() Call With Threads
There are also times when you might want to add a Python sleep() call to a thread. Perhaps you‚Äôre running a migration script against a database with millions of records in production. You don‚Äôt want to cause any downtime, but you also don‚Äôt want to wait longer than necessary to finish the migration, so you decide to use threads.

Note: Threads are a method of doing concurrency in Python. You can run multiple threads at once to increase your application‚Äôs throughput. If you‚Äôre not familiar with threads in Python, then check out An Intro to Threading in Python.

To prevent customers from noticing any kind of slowdown, each thread needs to run for a short period and then sleep. There are two ways to do this:

Use time.sleep() as before.
Use Event.wait() from the threading module.

Let‚Äôs start by looking at time.sleep().
Using time.sleep()
The Python Logging Cookbook shows a nice example that uses time.sleep(). Python‚Äôs logging module is thread-safe, so it‚Äôs a bit more useful than print() statements for this exercise. The following code is based on this example:
import logging
import threading
import time

def worker(arg):
    while not arg["stop"]:
        logging.debug("worker thread checking in")
        time.sleep(1)

def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(relativeCreated)6d %(threadName)s %(message)s"
    )
    info = {"stop": False}
    thread = threading.Thread(target=worker, args=(info,))
    thread_two = threading.Thread(target=worker, args=(info,))
    thread.start()
    thread_two.start()

    while True:
        try:
            logging.debug("Checking in from main thread")
            time.sleep(0.75)
        except KeyboardInterrupt:
            info["stop"] = True
            logging.debug('Stopping')
            break
    thread.join()
    thread_two.join()

if __name__ == "__main__":
    main()

Here, you use Python‚Äôs threading module to create two threads. You also create a logging object that will log the threadName to stdout. Next, you start both threads and initiate a loop to log from the main thread every so often. You use KeyboardInterrupt to catch the user pressing Ctrl+C.
Try running the code above in your terminal. You should see output similar to the following:
 0 Thread-1 worker thread checking in
 1 Thread-2 worker thread checking in
 1 MainThread Checking in from main thread
752 MainThread Checking in from main thread
1001 Thread-1 worker thread checking in
1001 Thread-2 worker thread checking in
1502 MainThread Checking in from main thread
2003 Thread-1 worker thread checking in
2003 Thread-2 worker thread checking in
2253 MainThread Checking in from main thread
3005 Thread-1 worker thread checking in
3005 MainThread Checking in from main thread
3005 Thread-2 worker thread checking in

As each thread runs and then sleeps, the logging output is printed to the console. Now that you‚Äôve tried an example, you‚Äôll be able to use these concepts in your own code.
Using Event.wait()
The threading module provides an Event() that you can use like time.sleep(). However, Event() has the added benefit of being more responsive. The reason for this is that when the event is set, the program will break out of the loop immediately. With time.sleep(), your code will need to wait for the Python sleep() call to finish before the thread can exit.
The reason you‚Äôd want to use wait() here is because wait() is non-blocking, whereas time.sleep() is blocking. What this means is that when you use time.sleep(), you‚Äôll block the main thread from continuing to run while it waits for the sleep() call to end. wait() solves this problem. You can read more about how all this works in Python‚Äôs threading documentation.
Here‚Äôs how you add a Python sleep() call with Event.wait():
import logging
import threading

def worker(event):
    while not event.isSet():
        logging.debug("worker thread checking in")
        event.wait(1)

def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(relativeCreated)6d %(threadName)s %(message)s"
    )
    event = threading.Event()

    thread = threading.Thread(target=worker, args=(event,))
    thread_two = threading.Thread(target=worker, args=(event,))
    thread.start()
    thread_two.start()

    while not event.isSet():
        try:
            logging.debug("Checking in from main thread")
            event.wait(0.75)
        except KeyboardInterrupt:
            event.set()
            break

if __name__ == "__main__":
    main()

In this example, you create threading.Event() and pass it to worker(). (Recall that in the previous example, you instead passed a dictionary.) Next, you set up your loops to check whether or not event is set. If it‚Äôs not, then your code prints a message and waits a bit before checking again. To set the event, you can press Ctrl+C. Once the event is set, worker() will return and the loop will break, ending the program.

Note: If you‚Äôd like to learn more about dictionaries, then check out Dictionaries in Python.

Take a closer look at the code block above. How would you pass in a different sleep time to each worker thread? Can you figure it out? Feel free to tackle this exercise on your own!
  Remove adsAdding a Python sleep() Call With Async IO
Asynchronous capabilities were added to Python in the 3.4 release, and this feature set has been aggressively expanding ever since. Asynchronous programming is a type of parallel programming that allows you to run multiple tasks at once. When a task finishes, it will notify the main thread.
asyncio is a module that lets you add a Python sleep() call asynchronously. If you‚Äôre unfamiliar with Python‚Äôs implementation of asynchronous programming, then check out Async IO in Python: A Complete Walkthrough and Python Concurrency & Parallel Programming.
Here‚Äôs an example from Python‚Äôs own documentation:
import asyncio

async def main():
    print('Hello ...')
    await asyncio.sleep(1)
    print('... World!')

# Python 3.7+
asyncio.run(main())

In this example, you run main() and have it sleep for one second between two print() calls.
Here‚Äôs a more compelling example from the Coroutines and Tasks portion of the asyncio documentation:
import asyncio
import time

async def output(sleep, text):
    await asyncio.sleep(sleep)
    print(text)

async def main():
    print(f"Started: {time.strftime('%X')}")
    await output(1, 'First')
    await output(2, 'Second')
    await output(3, 'Third')
    print(f"Ended: {time.strftime('%X')}")

# Python 3.7+
asyncio.run(main())

In this code, you create a worker called output() that takes in the number of seconds to sleep and the text to print out. Then, you use Python‚Äôs await keyword to wait for the output() code to run. await is required here because output() has been marked as an async function, so you can‚Äôt call it like you would a normal function.
When you run this code, your program will execute await 3 times. The code will wait for 1, 2, and 3 seconds, for a total wait time of 6 seconds. You can also rewrite the code so that the tasks run in parallel:
import asyncio
import time

async def output(text, sleep):
    while sleep > 0:
        await asyncio.sleep(1)
        print(f'{text} counter: {sleep} seconds')
        sleep -= 1

async def main():
    task_1 = asyncio.create_task(output('First', 1))
    task_2 = asyncio.create_task(output('Second', 2))
    task_3 = asyncio.create_task(output('Third', 3))
    print(f"Started: {time.strftime('%X')}")
    await task_1
    await task_2
    await task_3                                 
    print(f"Ended: {time.strftime('%X')}")

if __name__ == '__main__':
    asyncio.run(main())

Now you‚Äôre using the concept of tasks, which you can make with create_task(). When you use tasks in asyncio, Python will run the tasks asynchronously. So, when you run the code above, it should finish in 3 seconds total instead of 6.
Adding a Python sleep() Call With GUIs
Command-line applications aren‚Äôt the only place where you might need to add Python sleep() calls. When you create a Graphical User Interface (GUI), you‚Äôll occasionally need to add delays. For example, you might create an FTP application to download millions of files, but you need to add a sleep() call between batches so you don‚Äôt bog down the server.
GUI code will run all its processing and drawing in a main thread called the event loop. If you use time.sleep() inside of GUI code, then you‚Äôll block its event loop. From the user‚Äôs perspective, the application could appear to freeze. The user won‚Äôt be able to interact with your application while it‚Äôs sleeping with this method. (On Windows, you might even get an alert about how your application is now unresponsive.)
Fortunately, there are other methods you can use besides time.sleep(). In the next few sections, you‚Äôll learn how to add Python sleep() calls in both Tkinter and wxPython.
Sleeping in Tkinter
tkinter is a part of the Python standard library. It may not be available to you if you‚Äôre using a pre-installed version of Python on Linux or Mac. If you get an ImportError, then you‚Äôll need to look into how to add it to your system. But if you install Python yourself, then tkinter should already be available.
You‚Äôll start by looking at an example that uses time.sleep(). Run this code to see what happens when you add a Python sleep() call the wrong way:
import tkinter
import time

class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        b = tkinter.Button(text="click me", command=self.delayed)
        b.pack()

    def delayed(self):
        time.sleep(3)

if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()

Once you‚Äôve run the code, press the button in your GUI. The button will stick down for three seconds as it waits for sleep() to finish. If the application had other buttons, then you wouldn‚Äôt be able to click them. You can‚Äôt close the application while it‚Äôs sleeping, either, since it can‚Äôt respond to the close event.
To get tkinter to sleep properly, you‚Äôll need to use after():
import tkinter

class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        self.root.after(3000, self.delayed)

    def delayed(self):
        print('I was delayed')

if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()

Here you create an application that is 400 pixels wide by 400 pixels tall. It has no widgets on it. All it will do is show a frame. Then, you call self.root.after() where self.root is a reference to the Tk() object. after() takes two arguments:

The number of milliseconds to sleep
The method to call when the sleep is finished

In this case, your application will print a string to stdout after 3 seconds. You can think of after() as the tkinter version of time.sleep(), but it also adds the ability to call a function after the sleep has finished.
You could use this functionality to improve user experience. By adding a Python sleep() call, you can make the application appear to load faster and then start some longer-running process after it‚Äôs up. That way, the user won‚Äôt have to wait for the application to open.
  Remove adsSleeping in wxPython
There are two major differences between wxPython and Tkinter:

wxPython has many more widgets.
wxPython aims to look and feel native on all platforms.

The wxPython framework is not included with Python, so you‚Äôll need to install it yourself. If you‚Äôre not familiar with wxPython, then check out How to Build a Python GUI Application With wxPython.
In wxPython, you can use wx.CallLater() to add a Python sleep() call:
import wx

class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(parent=None, title='Hello World')
        wx.CallLater(4000, self.delayed)
        self.Show()

    def delayed(self):
        print('I was delayed')

if __name__ == '__main__':
    app = wx.App()
    frame = MyFrame()
    app.MainLoop()

Here, you subclass wx.Frame directly and then call wx.CallLater(). This function takes the same parameters as Tkinter‚Äôs after():

The number of milliseconds to sleep
The method to call when the sleep is finished

When you run this code, you should see a small blank window appear without any widgets. After 4 seconds, you‚Äôll see the string 'I was delayed' printed to stdout.
One of the benefits of using wx.CallLater() is that it‚Äôs thread-safe. You can use this method from within a thread to call a function that‚Äôs in the main wxPython application.
Conclusion
With this tutorial, you‚Äôve gained a valuable new technique to add to your Python toolbox! You know how to add delays to pace your applications and prevent them from using up system resources. You can even use Python sleep() calls to help your GUI code redraw more effectively. This will make the user experience much better for your customers!
To recap, you‚Äôve learned how to add Python sleep() calls with the following tools:

time.sleep()
Decorators
Threads
asyncio
Tkinter
wxPython

Now you can take what you‚Äôve learned and start putting your code to sleep!



Mark as Completed





üêç Python Tricks üíå




Get a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team.












Send Me Python Tricks ¬ª






About Mike Driscoll








Mike has been programming in Python for over a decade and loves writing about Python!
¬ª More about Mike








Each tutorial at Real Python is created by a team of developers so that it meets our high quality standards. The team members who worked on this tutorial are:






Aldren





Geir Arne





Jaya







Jon





Joanna









Master Real-World Python Skills With Unlimited Access to Real¬†Python

Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert¬†Pythonistas:
Level Up Your Python Skills ¬ª


Master Real-World Python SkillsWith Unlimited Access to Real¬†Python

Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Level Up Your Python Skills ¬ª



What Do You Think?


Tweet
Share
Email




Real Python Comment Policy: The most useful comments are those written with the goal of learning from or helping out other readers‚Äîafter reading the whole article and all the earlier comments. Complaints and insults generally won‚Äôt make the cut here.

What‚Äôs your #1 takeaway or favorite thing you learned? How are you going to put your newfound skills to use? Leave a comment below and let us know.





Keep Learning

Related Tutorial Categories:
intermediate
python








Master Real-World Python Skills With Unlimited Access to Real Python
Already a member? Sign-In





Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Unlock All Content ¬ª



Close









‚Äî FREE Email Series ‚Äî
üêç Python Tricks üíå







Get Python Tricks ¬ª
üîí No spam. Unsubscribe any time.



All Tutorial Topics
advanced
api
basics
best-practices
community
databases
data-science
devops
django
docker
flask
front-end
gui
intermediate
machine-learning
projects
python
testing
tools
web-dev
web-scraping









Table of Contents


Adding a Python sleep() Call With time.sleep()
Adding a Python sleep() Call With Decorators
Adding a Python sleep() Call With Threads
Using time.sleep()
Using Event.wait()


Adding a Python sleep() Call With Async IO
Adding a Python sleep() Call With GUIs
Sleeping in Tkinter
Sleeping in wxPython


Conclusion





Mark as Completed





Tweet
Share
Email

















Python sleep(): How to Add Time Delays to Your Code

by Mike Driscoll


intermediate
python


Mark as Completed




Tweet
Share
Email






Table of Contents


Adding a Python sleep() Call With time.sleep()
Adding a Python sleep() Call With Decorators
Adding a Python sleep() Call With Threads
Using time.sleep()
Using Event.wait()


Adding a Python sleep() Call With Async IO
Adding a Python sleep() Call With GUIs
Sleeping in Tkinter
Sleeping in wxPython


Conclusion








   Remove ads

Have you ever needed to make your Python program wait for something? Most of the time, you‚Äôd want your code to execute as quickly as possible. But there are times when letting your code sleep for a while is actually in your best interest.
For example, you might use a Python sleep() call to simulate a delay in your program. Perhaps you need to wait for a file to upload or download, or for a graphic to load or be drawn to the screen. You might even need to pause between calls to a web API, or between queries to a database. Adding Python sleep() calls to your program can help in each of these cases, and many more!
In this tutorial, you‚Äôll learn how to add Python sleep() calls with:

time.sleep()
Decorators
Threads
Async IO
Graphical User Interfaces

This article is intended for intermediate developers who are looking to grow their knowledge of Python. If that sounds like you, then let‚Äôs get started!
Free Bonus: Get our free "The Power of Python Decorators" guide that shows you 3 advanced decorator patterns and techniques you can use to write to cleaner and more Pythonic programs.
  Remove adsAdding a Python sleep() Call With time.sleep()
Python has built-in support for putting your program to sleep. The time module has a function sleep() that you can use to suspend execution of the calling thread for however many seconds you specify.
Here‚Äôs an example of how to use time.sleep():
>>>>>> import time
>>> time.sleep(3) # Sleep for 3 seconds

If you run this code in your console, then you should experience a delay before you can enter a new statement in the REPL.

Note: In Python 3.5, the core developers changed the behavior of time.sleep() slightly. The new Python sleep() system call will last at least the number of seconds you‚Äôve specified, even if the sleep is interrupted by a signal. This does not apply if the signal itself raises an exception, however.

You can test how long the sleep lasts by using Python‚Äôs timeit module:
$ python3 -m timeit -n 3 "import time; time.sleep(3)"
3 loops, best of 3: 3 sec per loop

Here, you run the timeit module with the -n parameter, which tells timeit how many times to run the statement that follows. You can see that timeit ran the statement 3 times and that the best run time was 3 seconds, which is what was expected.
The default number of times that timeit will run your code is one million. If you were to run the above code with the default -n, then at 3 seconds per iteration, your terminal would hang for approximately 34 days! The timeit module has several other command line options that you can check out in its documentation.
Let‚Äôs create something a bit more realistic. A system administrator needs to know when one of their websites goes down. You want to be able to check the website‚Äôs status code regularly, but you can‚Äôt query the web server constantly or it will affect performance. One way to do this check is to use a Python sleep() system call:
import time
import urllib.request
import urllib.error

def uptime_bot(url):
    while True:
        try:
            conn = urllib.request.urlopen(url)
        except urllib.error.HTTPError as e:
            # Email admin / log
            print(f'HTTPError: {e.code} for {url}')
        except urllib.error.URLError as e:
            # Email admin / log
            print(f'URLError: {e.code} for {url}')
        else:
            # Website is up
            print(f'{url} is up')
        time.sleep(60)

if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)

Here you create uptime_bot(), which takes a URL as its argument. The function then attempts to open that URL with urllib. If there‚Äôs an HTTPError or URLError, then the program catches it and prints out the error. (In a live environment, you would log the error and probably send out an email to the webmaster or system administrator.)
If no errors occur, then your code prints out that all is well. Regardless of what happens, your program will sleep for 60 seconds. This means that you only access the website once every minute. The URL used in this example is bad, so it will output the following to your console once every minute:
HTTPError: 404 for http://www.google.com/py

Go ahead and update the code to use a known good URL, like http://www.google.com. Then you can re-run it to see it work successfully. You can also try to update the code to send an email or log the errors. For more information on how to do this, check out Sending Emails With Python and Logging in Python.
Adding a Python sleep() Call With Decorators
There are times when you need to retry a function that has failed. One popular use case for this is when you need to retry a file download because the server was busy. You usually won‚Äôt want to make a request to the server too often, so adding a Python sleep() call between each request is desirable.
Another use case that I‚Äôve personally experienced is where I need to check the state of a user interface during an automated test. The user interface might load faster or slower than usual, depending on the computer I‚Äôm running the test on. This can change what‚Äôs on the screen at the moment my program is verifying something.
In this case, I can tell the program to sleep for a moment and then recheck things a second or two later. This can mean the difference between a passing and failing test.
You can use a decorator to add a Python sleep() system call in either of these cases. If you‚Äôre not familiar with decorators, or if you‚Äôd like to brush up on them, then check out Primer on Python Decorators. Let‚Äôs look at an example:
import time
import urllib.request
import urllib.error

def sleep(timeout, retry=3):
    def the_real_decorator(function):
        def wrapper(*args, **kwargs):
            retries = 0
            while retries < retry:
                try:
                    value = function(*args, **kwargs)
                    if value is None:
                        return
                except:
                    print(f'Sleeping for {timeout} seconds')
                    time.sleep(timeout)
                    retries += 1
        return wrapper
    return the_real_decorator

sleep() is your decorator. It accepts a timeout value and the number of times it should retry, which defaults to 3. Inside sleep() is another function, the_real_decorator(), which accepts the decorated function.
Finally, the innermost function wrapper() accepts the arguments and keyword arguments that you pass to the decorated function. This is where the magic happens! You use a while loop to retry calling the function. If there‚Äôs an exception, then you call time.sleep(), increment the retries counter, and try running the function again.
Now rewrite uptime_bot() to use your new decorator:
@sleep(3)
def uptime_bot(url):
    try:
        conn = urllib.request.urlopen(url)
    except urllib.error.HTTPError as e:
        # Email admin / log
        print(f'HTTPError: {e.code} for {url}')
        # Re-raise the exception for the decorator
        raise urllib.error.HTTPError
    except urllib.error.URLError as e:
        # Email admin / log
        print(f'URLError: {e.code} for {url}')
        # Re-raise the exception for the decorator
        raise urllib.error.URLError
    else:
        # Website is up
        print(f'{url} is up')

if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)

Here, you decorate uptime_bot() with a sleep() of 3 seconds. You‚Äôve also removed the original while loop, as well as the old call to sleep(60). The decorator now takes care of this.
One other change you‚Äôve made is to add a raise inside of the exception handling blocks. This is so that the decorator will work properly. You could write the decorator to handle these errors, but since these exceptions only apply to urllib, you might be better off keeping the decorator the way it is. That way, it will work with a wider variety of functions.

Note: If you‚Äôd like to brush up on exception handling in Python, then check out Python Exceptions: An Introduction.

There are a few improvements that you could make to your decorator. If it runs out of retries and still fails, then you could have it re-raise the last error. The decorator will also wait 3 seconds after the last failure, which might be something you don‚Äôt want to happen. Feel free to try these out as an exercise!
  Remove adsAdding a Python sleep() Call With Threads
There are also times when you might want to add a Python sleep() call to a thread. Perhaps you‚Äôre running a migration script against a database with millions of records in production. You don‚Äôt want to cause any downtime, but you also don‚Äôt want to wait longer than necessary to finish the migration, so you decide to use threads.

Note: Threads are a method of doing concurrency in Python. You can run multiple threads at once to increase your application‚Äôs throughput. If you‚Äôre not familiar with threads in Python, then check out An Intro to Threading in Python.

To prevent customers from noticing any kind of slowdown, each thread needs to run for a short period and then sleep. There are two ways to do this:

Use time.sleep() as before.
Use Event.wait() from the threading module.

Let‚Äôs start by looking at time.sleep().
Using time.sleep()
The Python Logging Cookbook shows a nice example that uses time.sleep(). Python‚Äôs logging module is thread-safe, so it‚Äôs a bit more useful than print() statements for this exercise. The following code is based on this example:
import logging
import threading
import time

def worker(arg):
    while not arg["stop"]:
        logging.debug("worker thread checking in")
        time.sleep(1)

def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(relativeCreated)6d %(threadName)s %(message)s"
    )
    info = {"stop": False}
    thread = threading.Thread(target=worker, args=(info,))
    thread_two = threading.Thread(target=worker, args=(info,))
    thread.start()
    thread_two.start()

    while True:
        try:
            logging.debug("Checking in from main thread")
            time.sleep(0.75)
        except KeyboardInterrupt:
            info["stop"] = True
            logging.debug('Stopping')
            break
    thread.join()
    thread_two.join()

if __name__ == "__main__":
    main()

Here, you use Python‚Äôs threading module to create two threads. You also create a logging object that will log the threadName to stdout. Next, you start both threads and initiate a loop to log from the main thread every so often. You use KeyboardInterrupt to catch the user pressing Ctrl+C.
Try running the code above in your terminal. You should see output similar to the following:
 0 Thread-1 worker thread checking in
 1 Thread-2 worker thread checking in
 1 MainThread Checking in from main thread
752 MainThread Checking in from main thread
1001 Thread-1 worker thread checking in
1001 Thread-2 worker thread checking in
1502 MainThread Checking in from main thread
2003 Thread-1 worker thread checking in
2003 Thread-2 worker thread checking in
2253 MainThread Checking in from main thread
3005 Thread-1 worker thread checking in
3005 MainThread Checking in from main thread
3005 Thread-2 worker thread checking in

As each thread runs and then sleeps, the logging output is printed to the console. Now that you‚Äôve tried an example, you‚Äôll be able to use these concepts in your own code.
Using Event.wait()
The threading module provides an Event() that you can use like time.sleep(). However, Event() has the added benefit of being more responsive. The reason for this is that when the event is set, the program will break out of the loop immediately. With time.sleep(), your code will need to wait for the Python sleep() call to finish before the thread can exit.
The reason you‚Äôd want to use wait() here is because wait() is non-blocking, whereas time.sleep() is blocking. What this means is that when you use time.sleep(), you‚Äôll block the main thread from continuing to run while it waits for the sleep() call to end. wait() solves this problem. You can read more about how all this works in Python‚Äôs threading documentation.
Here‚Äôs how you add a Python sleep() call with Event.wait():
import logging
import threading

def worker(event):
    while not event.isSet():
        logging.debug("worker thread checking in")
        event.wait(1)

def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(relativeCreated)6d %(threadName)s %(message)s"
    )
    event = threading.Event()

    thread = threading.Thread(target=worker, args=(event,))
    thread_two = threading.Thread(target=worker, args=(event,))
    thread.start()
    thread_two.start()

    while not event.isSet():
        try:
            logging.debug("Checking in from main thread")
            event.wait(0.75)
        except KeyboardInterrupt:
            event.set()
            break

if __name__ == "__main__":
    main()

In this example, you create threading.Event() and pass it to worker(). (Recall that in the previous example, you instead passed a dictionary.) Next, you set up your loops to check whether or not event is set. If it‚Äôs not, then your code prints a message and waits a bit before checking again. To set the event, you can press Ctrl+C. Once the event is set, worker() will return and the loop will break, ending the program.

Note: If you‚Äôd like to learn more about dictionaries, then check out Dictionaries in Python.

Take a closer look at the code block above. How would you pass in a different sleep time to each worker thread? Can you figure it out? Feel free to tackle this exercise on your own!
  Remove adsAdding a Python sleep() Call With Async IO
Asynchronous capabilities were added to Python in the 3.4 release, and this feature set has been aggressively expanding ever since. Asynchronous programming is a type of parallel programming that allows you to run multiple tasks at once. When a task finishes, it will notify the main thread.
asyncio is a module that lets you add a Python sleep() call asynchronously. If you‚Äôre unfamiliar with Python‚Äôs implementation of asynchronous programming, then check out Async IO in Python: A Complete Walkthrough and Python Concurrency & Parallel Programming.
Here‚Äôs an example from Python‚Äôs own documentation:
import asyncio

async def main():
    print('Hello ...')
    await asyncio.sleep(1)
    print('... World!')

# Python 3.7+
asyncio.run(main())

In this example, you run main() and have it sleep for one second between two print() calls.
Here‚Äôs a more compelling example from the Coroutines and Tasks portion of the asyncio documentation:
import asyncio
import time

async def output(sleep, text):
    await asyncio.sleep(sleep)
    print(text)

async def main():
    print(f"Started: {time.strftime('%X')}")
    await output(1, 'First')
    await output(2, 'Second')
    await output(3, 'Third')
    print(f"Ended: {time.strftime('%X')}")

# Python 3.7+
asyncio.run(main())

In this code, you create a worker called output() that takes in the number of seconds to sleep and the text to print out. Then, you use Python‚Äôs await keyword to wait for the output() code to run. await is required here because output() has been marked as an async function, so you can‚Äôt call it like you would a normal function.
When you run this code, your program will execute await 3 times. The code will wait for 1, 2, and 3 seconds, for a total wait time of 6 seconds. You can also rewrite the code so that the tasks run in parallel:
import asyncio
import time

async def output(text, sleep):
    while sleep > 0:
        await asyncio.sleep(1)
        print(f'{text} counter: {sleep} seconds')
        sleep -= 1

async def main():
    task_1 = asyncio.create_task(output('First', 1))
    task_2 = asyncio.create_task(output('Second', 2))
    task_3 = asyncio.create_task(output('Third', 3))
    print(f"Started: {time.strftime('%X')}")
    await task_1
    await task_2
    await task_3                                 
    print(f"Ended: {time.strftime('%X')}")

if __name__ == '__main__':
    asyncio.run(main())

Now you‚Äôre using the concept of tasks, which you can make with create_task(). When you use tasks in asyncio, Python will run the tasks asynchronously. So, when you run the code above, it should finish in 3 seconds total instead of 6.
Adding a Python sleep() Call With GUIs
Command-line applications aren‚Äôt the only place where you might need to add Python sleep() calls. When you create a Graphical User Interface (GUI), you‚Äôll occasionally need to add delays. For example, you might create an FTP application to download millions of files, but you need to add a sleep() call between batches so you don‚Äôt bog down the server.
GUI code will run all its processing and drawing in a main thread called the event loop. If you use time.sleep() inside of GUI code, then you‚Äôll block its event loop. From the user‚Äôs perspective, the application could appear to freeze. The user won‚Äôt be able to interact with your application while it‚Äôs sleeping with this method. (On Windows, you might even get an alert about how your application is now unresponsive.)
Fortunately, there are other methods you can use besides time.sleep(). In the next few sections, you‚Äôll learn how to add Python sleep() calls in both Tkinter and wxPython.
Sleeping in Tkinter
tkinter is a part of the Python standard library. It may not be available to you if you‚Äôre using a pre-installed version of Python on Linux or Mac. If you get an ImportError, then you‚Äôll need to look into how to add it to your system. But if you install Python yourself, then tkinter should already be available.
You‚Äôll start by looking at an example that uses time.sleep(). Run this code to see what happens when you add a Python sleep() call the wrong way:
import tkinter
import time

class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        b = tkinter.Button(text="click me", command=self.delayed)
        b.pack()

    def delayed(self):
        time.sleep(3)

if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()

Once you‚Äôve run the code, press the button in your GUI. The button will stick down for three seconds as it waits for sleep() to finish. If the application had other buttons, then you wouldn‚Äôt be able to click them. You can‚Äôt close the application while it‚Äôs sleeping, either, since it can‚Äôt respond to the close event.
To get tkinter to sleep properly, you‚Äôll need to use after():
import tkinter

class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        self.root.after(3000, self.delayed)

    def delayed(self):
        print('I was delayed')

if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()

Here you create an application that is 400 pixels wide by 400 pixels tall. It has no widgets on it. All it will do is show a frame. Then, you call self.root.after() where self.root is a reference to the Tk() object. after() takes two arguments:

The number of milliseconds to sleep
The method to call when the sleep is finished

In this case, your application will print a string to stdout after 3 seconds. You can think of after() as the tkinter version of time.sleep(), but it also adds the ability to call a function after the sleep has finished.
You could use this functionality to improve user experience. By adding a Python sleep() call, you can make the application appear to load faster and then start some longer-running process after it‚Äôs up. That way, the user won‚Äôt have to wait for the application to open.
  Remove adsSleeping in wxPython
There are two major differences between wxPython and Tkinter:

wxPython has many more widgets.
wxPython aims to look and feel native on all platforms.

The wxPython framework is not included with Python, so you‚Äôll need to install it yourself. If you‚Äôre not familiar with wxPython, then check out How to Build a Python GUI Application With wxPython.
In wxPython, you can use wx.CallLater() to add a Python sleep() call:
import wx

class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(parent=None, title='Hello World')
        wx.CallLater(4000, self.delayed)
        self.Show()

    def delayed(self):
        print('I was delayed')

if __name__ == '__main__':
    app = wx.App()
    frame = MyFrame()
    app.MainLoop()

Here, you subclass wx.Frame directly and then call wx.CallLater(). This function takes the same parameters as Tkinter‚Äôs after():

The number of milliseconds to sleep
The method to call when the sleep is finished

When you run this code, you should see a small blank window appear without any widgets. After 4 seconds, you‚Äôll see the string 'I was delayed' printed to stdout.
One of the benefits of using wx.CallLater() is that it‚Äôs thread-safe. You can use this method from within a thread to call a function that‚Äôs in the main wxPython application.
Conclusion
With this tutorial, you‚Äôve gained a valuable new technique to add to your Python toolbox! You know how to add delays to pace your applications and prevent them from using up system resources. You can even use Python sleep() calls to help your GUI code redraw more effectively. This will make the user experience much better for your customers!
To recap, you‚Äôve learned how to add Python sleep() calls with the following tools:

time.sleep()
Decorators
Threads
asyncio
Tkinter
wxPython

Now you can take what you‚Äôve learned and start putting your code to sleep!



Mark as Completed





üêç Python Tricks üíå




Get a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team.












Send Me Python Tricks ¬ª






About Mike Driscoll








Mike has been programming in Python for over a decade and loves writing about Python!
¬ª More about Mike








Each tutorial at Real Python is created by a team of developers so that it meets our high quality standards. The team members who worked on this tutorial are:






Aldren





Geir Arne





Jaya







Jon





Joanna









Master Real-World Python Skills With Unlimited Access to Real¬†Python

Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert¬†Pythonistas:
Level Up Your Python Skills ¬ª


Master Real-World Python SkillsWith Unlimited Access to Real¬†Python

Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Level Up Your Python Skills ¬ª



What Do You Think?


Tweet
Share
Email




Real Python Comment Policy: The most useful comments are those written with the goal of learning from or helping out other readers‚Äîafter reading the whole article and all the earlier comments. Complaints and insults generally won‚Äôt make the cut here.

What‚Äôs your #1 takeaway or favorite thing you learned? How are you going to put your newfound skills to use? Leave a comment below and let us know.





Keep Learning

Related Tutorial Categories:
intermediate
python








Master Real-World Python Skills With Unlimited Access to Real Python
Already a member? Sign-In





Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Unlock All Content ¬ª



Close









‚Äî FREE Email Series ‚Äî
üêç Python Tricks üíå







Get Python Tricks ¬ª
üîí No spam. Unsubscribe any time.



All Tutorial Topics
advanced
api
basics
best-practices
community
databases
data-science
devops
django
docker
flask
front-end
gui
intermediate
machine-learning
projects
python
testing
tools
web-dev
web-scraping









Table of Contents


Adding a Python sleep() Call With time.sleep()
Adding a Python sleep() Call With Decorators
Adding a Python sleep() Call With Threads
Using time.sleep()
Using Event.wait()


Adding a Python sleep() Call With Async IO
Adding a Python sleep() Call With GUIs
Sleeping in Tkinter
Sleeping in wxPython


Conclusion





Mark as Completed





Tweet
Share
Email















Python sleep(): How to Add Time Delays to Your Code

by Mike Driscoll


intermediate
python


Mark as Completed




Tweet
Share
Email






Table of Contents


Adding a Python sleep() Call With time.sleep()
Adding a Python sleep() Call With Decorators
Adding a Python sleep() Call With Threads
Using time.sleep()
Using Event.wait()


Adding a Python sleep() Call With Async IO
Adding a Python sleep() Call With GUIs
Sleeping in Tkinter
Sleeping in wxPython


Conclusion








   Remove ads

Have you ever needed to make your Python program wait for something? Most of the time, you‚Äôd want your code to execute as quickly as possible. But there are times when letting your code sleep for a while is actually in your best interest.
For example, you might use a Python sleep() call to simulate a delay in your program. Perhaps you need to wait for a file to upload or download, or for a graphic to load or be drawn to the screen. You might even need to pause between calls to a web API, or between queries to a database. Adding Python sleep() calls to your program can help in each of these cases, and many more!
In this tutorial, you‚Äôll learn how to add Python sleep() calls with:

time.sleep()
Decorators
Threads
Async IO
Graphical User Interfaces

This article is intended for intermediate developers who are looking to grow their knowledge of Python. If that sounds like you, then let‚Äôs get started!
Free Bonus: Get our free "The Power of Python Decorators" guide that shows you 3 advanced decorator patterns and techniques you can use to write to cleaner and more Pythonic programs.
  Remove adsAdding a Python sleep() Call With time.sleep()
Python has built-in support for putting your program to sleep. The time module has a function sleep() that you can use to suspend execution of the calling thread for however many seconds you specify.
Here‚Äôs an example of how to use time.sleep():
>>>>>> import time
>>> time.sleep(3) # Sleep for 3 seconds

If you run this code in your console, then you should experience a delay before you can enter a new statement in the REPL.

Note: In Python 3.5, the core developers changed the behavior of time.sleep() slightly. The new Python sleep() system call will last at least the number of seconds you‚Äôve specified, even if the sleep is interrupted by a signal. This does not apply if the signal itself raises an exception, however.

You can test how long the sleep lasts by using Python‚Äôs timeit module:
$ python3 -m timeit -n 3 "import time; time.sleep(3)"
3 loops, best of 3: 3 sec per loop

Here, you run the timeit module with the -n parameter, which tells timeit how many times to run the statement that follows. You can see that timeit ran the statement 3 times and that the best run time was 3 seconds, which is what was expected.
The default number of times that timeit will run your code is one million. If you were to run the above code with the default -n, then at 3 seconds per iteration, your terminal would hang for approximately 34 days! The timeit module has several other command line options that you can check out in its documentation.
Let‚Äôs create something a bit more realistic. A system administrator needs to know when one of their websites goes down. You want to be able to check the website‚Äôs status code regularly, but you can‚Äôt query the web server constantly or it will affect performance. One way to do this check is to use a Python sleep() system call:
import time
import urllib.request
import urllib.error

def uptime_bot(url):
    while True:
        try:
            conn = urllib.request.urlopen(url)
        except urllib.error.HTTPError as e:
            # Email admin / log
            print(f'HTTPError: {e.code} for {url}')
        except urllib.error.URLError as e:
            # Email admin / log
            print(f'URLError: {e.code} for {url}')
        else:
            # Website is up
            print(f'{url} is up')
        time.sleep(60)

if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)

Here you create uptime_bot(), which takes a URL as its argument. The function then attempts to open that URL with urllib. If there‚Äôs an HTTPError or URLError, then the program catches it and prints out the error. (In a live environment, you would log the error and probably send out an email to the webmaster or system administrator.)
If no errors occur, then your code prints out that all is well. Regardless of what happens, your program will sleep for 60 seconds. This means that you only access the website once every minute. The URL used in this example is bad, so it will output the following to your console once every minute:
HTTPError: 404 for http://www.google.com/py

Go ahead and update the code to use a known good URL, like http://www.google.com. Then you can re-run it to see it work successfully. You can also try to update the code to send an email or log the errors. For more information on how to do this, check out Sending Emails With Python and Logging in Python.
Adding a Python sleep() Call With Decorators
There are times when you need to retry a function that has failed. One popular use case for this is when you need to retry a file download because the server was busy. You usually won‚Äôt want to make a request to the server too often, so adding a Python sleep() call between each request is desirable.
Another use case that I‚Äôve personally experienced is where I need to check the state of a user interface during an automated test. The user interface might load faster or slower than usual, depending on the computer I‚Äôm running the test on. This can change what‚Äôs on the screen at the moment my program is verifying something.
In this case, I can tell the program to sleep for a moment and then recheck things a second or two later. This can mean the difference between a passing and failing test.
You can use a decorator to add a Python sleep() system call in either of these cases. If you‚Äôre not familiar with decorators, or if you‚Äôd like to brush up on them, then check out Primer on Python Decorators. Let‚Äôs look at an example:
import time
import urllib.request
import urllib.error

def sleep(timeout, retry=3):
    def the_real_decorator(function):
        def wrapper(*args, **kwargs):
            retries = 0
            while retries < retry:
                try:
                    value = function(*args, **kwargs)
                    if value is None:
                        return
                except:
                    print(f'Sleeping for {timeout} seconds')
                    time.sleep(timeout)
                    retries += 1
        return wrapper
    return the_real_decorator

sleep() is your decorator. It accepts a timeout value and the number of times it should retry, which defaults to 3. Inside sleep() is another function, the_real_decorator(), which accepts the decorated function.
Finally, the innermost function wrapper() accepts the arguments and keyword arguments that you pass to the decorated function. This is where the magic happens! You use a while loop to retry calling the function. If there‚Äôs an exception, then you call time.sleep(), increment the retries counter, and try running the function again.
Now rewrite uptime_bot() to use your new decorator:
@sleep(3)
def uptime_bot(url):
    try:
        conn = urllib.request.urlopen(url)
    except urllib.error.HTTPError as e:
        # Email admin / log
        print(f'HTTPError: {e.code} for {url}')
        # Re-raise the exception for the decorator
        raise urllib.error.HTTPError
    except urllib.error.URLError as e:
        # Email admin / log
        print(f'URLError: {e.code} for {url}')
        # Re-raise the exception for the decorator
        raise urllib.error.URLError
    else:
        # Website is up
        print(f'{url} is up')

if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)

Here, you decorate uptime_bot() with a sleep() of 3 seconds. You‚Äôve also removed the original while loop, as well as the old call to sleep(60). The decorator now takes care of this.
One other change you‚Äôve made is to add a raise inside of the exception handling blocks. This is so that the decorator will work properly. You could write the decorator to handle these errors, but since these exceptions only apply to urllib, you might be better off keeping the decorator the way it is. That way, it will work with a wider variety of functions.

Note: If you‚Äôd like to brush up on exception handling in Python, then check out Python Exceptions: An Introduction.

There are a few improvements that you could make to your decorator. If it runs out of retries and still fails, then you could have it re-raise the last error. The decorator will also wait 3 seconds after the last failure, which might be something you don‚Äôt want to happen. Feel free to try these out as an exercise!
  Remove adsAdding a Python sleep() Call With Threads
There are also times when you might want to add a Python sleep() call to a thread. Perhaps you‚Äôre running a migration script against a database with millions of records in production. You don‚Äôt want to cause any downtime, but you also don‚Äôt want to wait longer than necessary to finish the migration, so you decide to use threads.

Note: Threads are a method of doing concurrency in Python. You can run multiple threads at once to increase your application‚Äôs throughput. If you‚Äôre not familiar with threads in Python, then check out An Intro to Threading in Python.

To prevent customers from noticing any kind of slowdown, each thread needs to run for a short period and then sleep. There are two ways to do this:

Use time.sleep() as before.
Use Event.wait() from the threading module.

Let‚Äôs start by looking at time.sleep().
Using time.sleep()
The Python Logging Cookbook shows a nice example that uses time.sleep(). Python‚Äôs logging module is thread-safe, so it‚Äôs a bit more useful than print() statements for this exercise. The following code is based on this example:
import logging
import threading
import time

def worker(arg):
    while not arg["stop"]:
        logging.debug("worker thread checking in")
        time.sleep(1)

def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(relativeCreated)6d %(threadName)s %(message)s"
    )
    info = {"stop": False}
    thread = threading.Thread(target=worker, args=(info,))
    thread_two = threading.Thread(target=worker, args=(info,))
    thread.start()
    thread_two.start()

    while True:
        try:
            logging.debug("Checking in from main thread")
            time.sleep(0.75)
        except KeyboardInterrupt:
            info["stop"] = True
            logging.debug('Stopping')
            break
    thread.join()
    thread_two.join()

if __name__ == "__main__":
    main()

Here, you use Python‚Äôs threading module to create two threads. You also create a logging object that will log the threadName to stdout. Next, you start both threads and initiate a loop to log from the main thread every so often. You use KeyboardInterrupt to catch the user pressing Ctrl+C.
Try running the code above in your terminal. You should see output similar to the following:
 0 Thread-1 worker thread checking in
 1 Thread-2 worker thread checking in
 1 MainThread Checking in from main thread
752 MainThread Checking in from main thread
1001 Thread-1 worker thread checking in
1001 Thread-2 worker thread checking in
1502 MainThread Checking in from main thread
2003 Thread-1 worker thread checking in
2003 Thread-2 worker thread checking in
2253 MainThread Checking in from main thread
3005 Thread-1 worker thread checking in
3005 MainThread Checking in from main thread
3005 Thread-2 worker thread checking in

As each thread runs and then sleeps, the logging output is printed to the console. Now that you‚Äôve tried an example, you‚Äôll be able to use these concepts in your own code.
Using Event.wait()
The threading module provides an Event() that you can use like time.sleep(). However, Event() has the added benefit of being more responsive. The reason for this is that when the event is set, the program will break out of the loop immediately. With time.sleep(), your code will need to wait for the Python sleep() call to finish before the thread can exit.
The reason you‚Äôd want to use wait() here is because wait() is non-blocking, whereas time.sleep() is blocking. What this means is that when you use time.sleep(), you‚Äôll block the main thread from continuing to run while it waits for the sleep() call to end. wait() solves this problem. You can read more about how all this works in Python‚Äôs threading documentation.
Here‚Äôs how you add a Python sleep() call with Event.wait():
import logging
import threading

def worker(event):
    while not event.isSet():
        logging.debug("worker thread checking in")
        event.wait(1)

def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(relativeCreated)6d %(threadName)s %(message)s"
    )
    event = threading.Event()

    thread = threading.Thread(target=worker, args=(event,))
    thread_two = threading.Thread(target=worker, args=(event,))
    thread.start()
    thread_two.start()

    while not event.isSet():
        try:
            logging.debug("Checking in from main thread")
            event.wait(0.75)
        except KeyboardInterrupt:
            event.set()
            break

if __name__ == "__main__":
    main()

In this example, you create threading.Event() and pass it to worker(). (Recall that in the previous example, you instead passed a dictionary.) Next, you set up your loops to check whether or not event is set. If it‚Äôs not, then your code prints a message and waits a bit before checking again. To set the event, you can press Ctrl+C. Once the event is set, worker() will return and the loop will break, ending the program.

Note: If you‚Äôd like to learn more about dictionaries, then check out Dictionaries in Python.

Take a closer look at the code block above. How would you pass in a different sleep time to each worker thread? Can you figure it out? Feel free to tackle this exercise on your own!
  Remove adsAdding a Python sleep() Call With Async IO
Asynchronous capabilities were added to Python in the 3.4 release, and this feature set has been aggressively expanding ever since. Asynchronous programming is a type of parallel programming that allows you to run multiple tasks at once. When a task finishes, it will notify the main thread.
asyncio is a module that lets you add a Python sleep() call asynchronously. If you‚Äôre unfamiliar with Python‚Äôs implementation of asynchronous programming, then check out Async IO in Python: A Complete Walkthrough and Python Concurrency & Parallel Programming.
Here‚Äôs an example from Python‚Äôs own documentation:
import asyncio

async def main():
    print('Hello ...')
    await asyncio.sleep(1)
    print('... World!')

# Python 3.7+
asyncio.run(main())

In this example, you run main() and have it sleep for one second between two print() calls.
Here‚Äôs a more compelling example from the Coroutines and Tasks portion of the asyncio documentation:
import asyncio
import time

async def output(sleep, text):
    await asyncio.sleep(sleep)
    print(text)

async def main():
    print(f"Started: {time.strftime('%X')}")
    await output(1, 'First')
    await output(2, 'Second')
    await output(3, 'Third')
    print(f"Ended: {time.strftime('%X')}")

# Python 3.7+
asyncio.run(main())

In this code, you create a worker called output() that takes in the number of seconds to sleep and the text to print out. Then, you use Python‚Äôs await keyword to wait for the output() code to run. await is required here because output() has been marked as an async function, so you can‚Äôt call it like you would a normal function.
When you run this code, your program will execute await 3 times. The code will wait for 1, 2, and 3 seconds, for a total wait time of 6 seconds. You can also rewrite the code so that the tasks run in parallel:
import asyncio
import time

async def output(text, sleep):
    while sleep > 0:
        await asyncio.sleep(1)
        print(f'{text} counter: {sleep} seconds')
        sleep -= 1

async def main():
    task_1 = asyncio.create_task(output('First', 1))
    task_2 = asyncio.create_task(output('Second', 2))
    task_3 = asyncio.create_task(output('Third', 3))
    print(f"Started: {time.strftime('%X')}")
    await task_1
    await task_2
    await task_3                                 
    print(f"Ended: {time.strftime('%X')}")

if __name__ == '__main__':
    asyncio.run(main())

Now you‚Äôre using the concept of tasks, which you can make with create_task(). When you use tasks in asyncio, Python will run the tasks asynchronously. So, when you run the code above, it should finish in 3 seconds total instead of 6.
Adding a Python sleep() Call With GUIs
Command-line applications aren‚Äôt the only place where you might need to add Python sleep() calls. When you create a Graphical User Interface (GUI), you‚Äôll occasionally need to add delays. For example, you might create an FTP application to download millions of files, but you need to add a sleep() call between batches so you don‚Äôt bog down the server.
GUI code will run all its processing and drawing in a main thread called the event loop. If you use time.sleep() inside of GUI code, then you‚Äôll block its event loop. From the user‚Äôs perspective, the application could appear to freeze. The user won‚Äôt be able to interact with your application while it‚Äôs sleeping with this method. (On Windows, you might even get an alert about how your application is now unresponsive.)
Fortunately, there are other methods you can use besides time.sleep(). In the next few sections, you‚Äôll learn how to add Python sleep() calls in both Tkinter and wxPython.
Sleeping in Tkinter
tkinter is a part of the Python standard library. It may not be available to you if you‚Äôre using a pre-installed version of Python on Linux or Mac. If you get an ImportError, then you‚Äôll need to look into how to add it to your system. But if you install Python yourself, then tkinter should already be available.
You‚Äôll start by looking at an example that uses time.sleep(). Run this code to see what happens when you add a Python sleep() call the wrong way:
import tkinter
import time

class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        b = tkinter.Button(text="click me", command=self.delayed)
        b.pack()

    def delayed(self):
        time.sleep(3)

if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()

Once you‚Äôve run the code, press the button in your GUI. The button will stick down for three seconds as it waits for sleep() to finish. If the application had other buttons, then you wouldn‚Äôt be able to click them. You can‚Äôt close the application while it‚Äôs sleeping, either, since it can‚Äôt respond to the close event.
To get tkinter to sleep properly, you‚Äôll need to use after():
import tkinter

class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        self.root.after(3000, self.delayed)

    def delayed(self):
        print('I was delayed')

if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()

Here you create an application that is 400 pixels wide by 400 pixels tall. It has no widgets on it. All it will do is show a frame. Then, you call self.root.after() where self.root is a reference to the Tk() object. after() takes two arguments:

The number of milliseconds to sleep
The method to call when the sleep is finished

In this case, your application will print a string to stdout after 3 seconds. You can think of after() as the tkinter version of time.sleep(), but it also adds the ability to call a function after the sleep has finished.
You could use this functionality to improve user experience. By adding a Python sleep() call, you can make the application appear to load faster and then start some longer-running process after it‚Äôs up. That way, the user won‚Äôt have to wait for the application to open.
  Remove adsSleeping in wxPython
There are two major differences between wxPython and Tkinter:

wxPython has many more widgets.
wxPython aims to look and feel native on all platforms.

The wxPython framework is not included with Python, so you‚Äôll need to install it yourself. If you‚Äôre not familiar with wxPython, then check out How to Build a Python GUI Application With wxPython.
In wxPython, you can use wx.CallLater() to add a Python sleep() call:
import wx

class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(parent=None, title='Hello World')
        wx.CallLater(4000, self.delayed)
        self.Show()

    def delayed(self):
        print('I was delayed')

if __name__ == '__main__':
    app = wx.App()
    frame = MyFrame()
    app.MainLoop()

Here, you subclass wx.Frame directly and then call wx.CallLater(). This function takes the same parameters as Tkinter‚Äôs after():

The number of milliseconds to sleep
The method to call when the sleep is finished

When you run this code, you should see a small blank window appear without any widgets. After 4 seconds, you‚Äôll see the string 'I was delayed' printed to stdout.
One of the benefits of using wx.CallLater() is that it‚Äôs thread-safe. You can use this method from within a thread to call a function that‚Äôs in the main wxPython application.
Conclusion
With this tutorial, you‚Äôve gained a valuable new technique to add to your Python toolbox! You know how to add delays to pace your applications and prevent them from using up system resources. You can even use Python sleep() calls to help your GUI code redraw more effectively. This will make the user experience much better for your customers!
To recap, you‚Äôve learned how to add Python sleep() calls with the following tools:

time.sleep()
Decorators
Threads
asyncio
Tkinter
wxPython

Now you can take what you‚Äôve learned and start putting your code to sleep!



Mark as Completed





üêç Python Tricks üíå




Get a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team.












Send Me Python Tricks ¬ª






About Mike Driscoll








Mike has been programming in Python for over a decade and loves writing about Python!
¬ª More about Mike








Each tutorial at Real Python is created by a team of developers so that it meets our high quality standards. The team members who worked on this tutorial are:






Aldren





Geir Arne





Jaya







Jon





Joanna









Master Real-World Python Skills With Unlimited Access to Real¬†Python

Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert¬†Pythonistas:
Level Up Your Python Skills ¬ª


Master Real-World Python SkillsWith Unlimited Access to Real¬†Python

Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Level Up Your Python Skills ¬ª



What Do You Think?


Tweet
Share
Email




Real Python Comment Policy: The most useful comments are those written with the goal of learning from or helping out other readers‚Äîafter reading the whole article and all the earlier comments. Complaints and insults generally won‚Äôt make the cut here.

What‚Äôs your #1 takeaway or favorite thing you learned? How are you going to put your newfound skills to use? Leave a comment below and let us know.





Keep Learning

Related Tutorial Categories:
intermediate
python








Master Real-World Python Skills With Unlimited Access to Real Python
Already a member? Sign-In





Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Unlock All Content ¬ª



Close







Mark as Completed




Tweet
Share
Email




Mark as Completed




Tweet
Share
Email




Table of Contents


Adding a Python sleep() Call With time.sleep()
Adding a Python sleep() Call With Decorators
Adding a Python sleep() Call With Threads
Using time.sleep()
Using Event.wait()


Adding a Python sleep() Call With Async IO
Adding a Python sleep() Call With GUIs
Sleeping in Tkinter
Sleeping in wxPython


Conclusion








   Remove ads

Have you ever needed to make your Python program wait for something? Most of the time, you‚Äôd want your code to execute as quickly as possible. But there are times when letting your code sleep for a while is actually in your best interest.
For example, you might use a Python sleep() call to simulate a delay in your program. Perhaps you need to wait for a file to upload or download, or for a graphic to load or be drawn to the screen. You might even need to pause between calls to a web API, or between queries to a database. Adding Python sleep() calls to your program can help in each of these cases, and many more!
In this tutorial, you‚Äôll learn how to add Python sleep() calls with:

time.sleep()
Decorators
Threads
Async IO
Graphical User Interfaces

This article is intended for intermediate developers who are looking to grow their knowledge of Python. If that sounds like you, then let‚Äôs get started!
Free Bonus: Get our free "The Power of Python Decorators" guide that shows you 3 advanced decorator patterns and techniques you can use to write to cleaner and more Pythonic programs.
  Remove adsAdding a Python sleep() Call With time.sleep()
Python has built-in support for putting your program to sleep. The time module has a function sleep() that you can use to suspend execution of the calling thread for however many seconds you specify.
Here‚Äôs an example of how to use time.sleep():
>>>>>> import time
>>> time.sleep(3) # Sleep for 3 seconds

If you run this code in your console, then you should experience a delay before you can enter a new statement in the REPL.

Note: In Python 3.5, the core developers changed the behavior of time.sleep() slightly. The new Python sleep() system call will last at least the number of seconds you‚Äôve specified, even if the sleep is interrupted by a signal. This does not apply if the signal itself raises an exception, however.

You can test how long the sleep lasts by using Python‚Äôs timeit module:
$ python3 -m timeit -n 3 "import time; time.sleep(3)"
3 loops, best of 3: 3 sec per loop

Here, you run the timeit module with the -n parameter, which tells timeit how many times to run the statement that follows. You can see that timeit ran the statement 3 times and that the best run time was 3 seconds, which is what was expected.
The default number of times that timeit will run your code is one million. If you were to run the above code with the default -n, then at 3 seconds per iteration, your terminal would hang for approximately 34 days! The timeit module has several other command line options that you can check out in its documentation.
Let‚Äôs create something a bit more realistic. A system administrator needs to know when one of their websites goes down. You want to be able to check the website‚Äôs status code regularly, but you can‚Äôt query the web server constantly or it will affect performance. One way to do this check is to use a Python sleep() system call:
import time
import urllib.request
import urllib.error

def uptime_bot(url):
    while True:
        try:
            conn = urllib.request.urlopen(url)
        except urllib.error.HTTPError as e:
            # Email admin / log
            print(f'HTTPError: {e.code} for {url}')
        except urllib.error.URLError as e:
            # Email admin / log
            print(f'URLError: {e.code} for {url}')
        else:
            # Website is up
            print(f'{url} is up')
        time.sleep(60)

if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)

Here you create uptime_bot(), which takes a URL as its argument. The function then attempts to open that URL with urllib. If there‚Äôs an HTTPError or URLError, then the program catches it and prints out the error. (In a live environment, you would log the error and probably send out an email to the webmaster or system administrator.)
If no errors occur, then your code prints out that all is well. Regardless of what happens, your program will sleep for 60 seconds. This means that you only access the website once every minute. The URL used in this example is bad, so it will output the following to your console once every minute:
HTTPError: 404 for http://www.google.com/py

Go ahead and update the code to use a known good URL, like http://www.google.com. Then you can re-run it to see it work successfully. You can also try to update the code to send an email or log the errors. For more information on how to do this, check out Sending Emails With Python and Logging in Python.
Adding a Python sleep() Call With Decorators
There are times when you need to retry a function that has failed. One popular use case for this is when you need to retry a file download because the server was busy. You usually won‚Äôt want to make a request to the server too often, so adding a Python sleep() call between each request is desirable.
Another use case that I‚Äôve personally experienced is where I need to check the state of a user interface during an automated test. The user interface might load faster or slower than usual, depending on the computer I‚Äôm running the test on. This can change what‚Äôs on the screen at the moment my program is verifying something.
In this case, I can tell the program to sleep for a moment and then recheck things a second or two later. This can mean the difference between a passing and failing test.
You can use a decorator to add a Python sleep() system call in either of these cases. If you‚Äôre not familiar with decorators, or if you‚Äôd like to brush up on them, then check out Primer on Python Decorators. Let‚Äôs look at an example:
import time
import urllib.request
import urllib.error

def sleep(timeout, retry=3):
    def the_real_decorator(function):
        def wrapper(*args, **kwargs):
            retries = 0
            while retries < retry:
                try:
                    value = function(*args, **kwargs)
                    if value is None:
                        return
                except:
                    print(f'Sleeping for {timeout} seconds')
                    time.sleep(timeout)
                    retries += 1
        return wrapper
    return the_real_decorator

sleep() is your decorator. It accepts a timeout value and the number of times it should retry, which defaults to 3. Inside sleep() is another function, the_real_decorator(), which accepts the decorated function.
Finally, the innermost function wrapper() accepts the arguments and keyword arguments that you pass to the decorated function. This is where the magic happens! You use a while loop to retry calling the function. If there‚Äôs an exception, then you call time.sleep(), increment the retries counter, and try running the function again.
Now rewrite uptime_bot() to use your new decorator:
@sleep(3)
def uptime_bot(url):
    try:
        conn = urllib.request.urlopen(url)
    except urllib.error.HTTPError as e:
        # Email admin / log
        print(f'HTTPError: {e.code} for {url}')
        # Re-raise the exception for the decorator
        raise urllib.error.HTTPError
    except urllib.error.URLError as e:
        # Email admin / log
        print(f'URLError: {e.code} for {url}')
        # Re-raise the exception for the decorator
        raise urllib.error.URLError
    else:
        # Website is up
        print(f'{url} is up')

if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)

Here, you decorate uptime_bot() with a sleep() of 3 seconds. You‚Äôve also removed the original while loop, as well as the old call to sleep(60). The decorator now takes care of this.
One other change you‚Äôve made is to add a raise inside of the exception handling blocks. This is so that the decorator will work properly. You could write the decorator to handle these errors, but since these exceptions only apply to urllib, you might be better off keeping the decorator the way it is. That way, it will work with a wider variety of functions.

Note: If you‚Äôd like to brush up on exception handling in Python, then check out Python Exceptions: An Introduction.

There are a few improvements that you could make to your decorator. If it runs out of retries and still fails, then you could have it re-raise the last error. The decorator will also wait 3 seconds after the last failure, which might be something you don‚Äôt want to happen. Feel free to try these out as an exercise!
  Remove adsAdding a Python sleep() Call With Threads
There are also times when you might want to add a Python sleep() call to a thread. Perhaps you‚Äôre running a migration script against a database with millions of records in production. You don‚Äôt want to cause any downtime, but you also don‚Äôt want to wait longer than necessary to finish the migration, so you decide to use threads.

Note: Threads are a method of doing concurrency in Python. You can run multiple threads at once to increase your application‚Äôs throughput. If you‚Äôre not familiar with threads in Python, then check out An Intro to Threading in Python.

To prevent customers from noticing any kind of slowdown, each thread needs to run for a short period and then sleep. There are two ways to do this:

Use time.sleep() as before.
Use Event.wait() from the threading module.

Let‚Äôs start by looking at time.sleep().
Using time.sleep()
The Python Logging Cookbook shows a nice example that uses time.sleep(). Python‚Äôs logging module is thread-safe, so it‚Äôs a bit more useful than print() statements for this exercise. The following code is based on this example:
import logging
import threading
import time

def worker(arg):
    while not arg["stop"]:
        logging.debug("worker thread checking in")
        time.sleep(1)

def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(relativeCreated)6d %(threadName)s %(message)s"
    )
    info = {"stop": False}
    thread = threading.Thread(target=worker, args=(info,))
    thread_two = threading.Thread(target=worker, args=(info,))
    thread.start()
    thread_two.start()

    while True:
        try:
            logging.debug("Checking in from main thread")
            time.sleep(0.75)
        except KeyboardInterrupt:
            info["stop"] = True
            logging.debug('Stopping')
            break
    thread.join()
    thread_two.join()

if __name__ == "__main__":
    main()

Here, you use Python‚Äôs threading module to create two threads. You also create a logging object that will log the threadName to stdout. Next, you start both threads and initiate a loop to log from the main thread every so often. You use KeyboardInterrupt to catch the user pressing Ctrl+C.
Try running the code above in your terminal. You should see output similar to the following:
 0 Thread-1 worker thread checking in
 1 Thread-2 worker thread checking in
 1 MainThread Checking in from main thread
752 MainThread Checking in from main thread
1001 Thread-1 worker thread checking in
1001 Thread-2 worker thread checking in
1502 MainThread Checking in from main thread
2003 Thread-1 worker thread checking in
2003 Thread-2 worker thread checking in
2253 MainThread Checking in from main thread
3005 Thread-1 worker thread checking in
3005 MainThread Checking in from main thread
3005 Thread-2 worker thread checking in

As each thread runs and then sleeps, the logging output is printed to the console. Now that you‚Äôve tried an example, you‚Äôll be able to use these concepts in your own code.
Using Event.wait()
The threading module provides an Event() that you can use like time.sleep(). However, Event() has the added benefit of being more responsive. The reason for this is that when the event is set, the program will break out of the loop immediately. With time.sleep(), your code will need to wait for the Python sleep() call to finish before the thread can exit.
The reason you‚Äôd want to use wait() here is because wait() is non-blocking, whereas time.sleep() is blocking. What this means is that when you use time.sleep(), you‚Äôll block the main thread from continuing to run while it waits for the sleep() call to end. wait() solves this problem. You can read more about how all this works in Python‚Äôs threading documentation.
Here‚Äôs how you add a Python sleep() call with Event.wait():
import logging
import threading

def worker(event):
    while not event.isSet():
        logging.debug("worker thread checking in")
        event.wait(1)

def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(relativeCreated)6d %(threadName)s %(message)s"
    )
    event = threading.Event()

    thread = threading.Thread(target=worker, args=(event,))
    thread_two = threading.Thread(target=worker, args=(event,))
    thread.start()
    thread_two.start()

    while not event.isSet():
        try:
            logging.debug("Checking in from main thread")
            event.wait(0.75)
        except KeyboardInterrupt:
            event.set()
            break

if __name__ == "__main__":
    main()

In this example, you create threading.Event() and pass it to worker(). (Recall that in the previous example, you instead passed a dictionary.) Next, you set up your loops to check whether or not event is set. If it‚Äôs not, then your code prints a message and waits a bit before checking again. To set the event, you can press Ctrl+C. Once the event is set, worker() will return and the loop will break, ending the program.

Note: If you‚Äôd like to learn more about dictionaries, then check out Dictionaries in Python.

Take a closer look at the code block above. How would you pass in a different sleep time to each worker thread? Can you figure it out? Feel free to tackle this exercise on your own!
  Remove adsAdding a Python sleep() Call With Async IO
Asynchronous capabilities were added to Python in the 3.4 release, and this feature set has been aggressively expanding ever since. Asynchronous programming is a type of parallel programming that allows you to run multiple tasks at once. When a task finishes, it will notify the main thread.
asyncio is a module that lets you add a Python sleep() call asynchronously. If you‚Äôre unfamiliar with Python‚Äôs implementation of asynchronous programming, then check out Async IO in Python: A Complete Walkthrough and Python Concurrency & Parallel Programming.
Here‚Äôs an example from Python‚Äôs own documentation:
import asyncio

async def main():
    print('Hello ...')
    await asyncio.sleep(1)
    print('... World!')

# Python 3.7+
asyncio.run(main())

In this example, you run main() and have it sleep for one second between two print() calls.
Here‚Äôs a more compelling example from the Coroutines and Tasks portion of the asyncio documentation:
import asyncio
import time

async def output(sleep, text):
    await asyncio.sleep(sleep)
    print(text)

async def main():
    print(f"Started: {time.strftime('%X')}")
    await output(1, 'First')
    await output(2, 'Second')
    await output(3, 'Third')
    print(f"Ended: {time.strftime('%X')}")

# Python 3.7+
asyncio.run(main())

In this code, you create a worker called output() that takes in the number of seconds to sleep and the text to print out. Then, you use Python‚Äôs await keyword to wait for the output() code to run. await is required here because output() has been marked as an async function, so you can‚Äôt call it like you would a normal function.
When you run this code, your program will execute await 3 times. The code will wait for 1, 2, and 3 seconds, for a total wait time of 6 seconds. You can also rewrite the code so that the tasks run in parallel:
import asyncio
import time

async def output(text, sleep):
    while sleep > 0:
        await asyncio.sleep(1)
        print(f'{text} counter: {sleep} seconds')
        sleep -= 1

async def main():
    task_1 = asyncio.create_task(output('First', 1))
    task_2 = asyncio.create_task(output('Second', 2))
    task_3 = asyncio.create_task(output('Third', 3))
    print(f"Started: {time.strftime('%X')}")
    await task_1
    await task_2
    await task_3                                 
    print(f"Ended: {time.strftime('%X')}")

if __name__ == '__main__':
    asyncio.run(main())

Now you‚Äôre using the concept of tasks, which you can make with create_task(). When you use tasks in asyncio, Python will run the tasks asynchronously. So, when you run the code above, it should finish in 3 seconds total instead of 6.
Adding a Python sleep() Call With GUIs
Command-line applications aren‚Äôt the only place where you might need to add Python sleep() calls. When you create a Graphical User Interface (GUI), you‚Äôll occasionally need to add delays. For example, you might create an FTP application to download millions of files, but you need to add a sleep() call between batches so you don‚Äôt bog down the server.
GUI code will run all its processing and drawing in a main thread called the event loop. If you use time.sleep() inside of GUI code, then you‚Äôll block its event loop. From the user‚Äôs perspective, the application could appear to freeze. The user won‚Äôt be able to interact with your application while it‚Äôs sleeping with this method. (On Windows, you might even get an alert about how your application is now unresponsive.)
Fortunately, there are other methods you can use besides time.sleep(). In the next few sections, you‚Äôll learn how to add Python sleep() calls in both Tkinter and wxPython.
Sleeping in Tkinter
tkinter is a part of the Python standard library. It may not be available to you if you‚Äôre using a pre-installed version of Python on Linux or Mac. If you get an ImportError, then you‚Äôll need to look into how to add it to your system. But if you install Python yourself, then tkinter should already be available.
You‚Äôll start by looking at an example that uses time.sleep(). Run this code to see what happens when you add a Python sleep() call the wrong way:
import tkinter
import time

class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        b = tkinter.Button(text="click me", command=self.delayed)
        b.pack()

    def delayed(self):
        time.sleep(3)

if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()

Once you‚Äôve run the code, press the button in your GUI. The button will stick down for three seconds as it waits for sleep() to finish. If the application had other buttons, then you wouldn‚Äôt be able to click them. You can‚Äôt close the application while it‚Äôs sleeping, either, since it can‚Äôt respond to the close event.
To get tkinter to sleep properly, you‚Äôll need to use after():
import tkinter

class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        self.root.after(3000, self.delayed)

    def delayed(self):
        print('I was delayed')

if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()

Here you create an application that is 400 pixels wide by 400 pixels tall. It has no widgets on it. All it will do is show a frame. Then, you call self.root.after() where self.root is a reference to the Tk() object. after() takes two arguments:

The number of milliseconds to sleep
The method to call when the sleep is finished

In this case, your application will print a string to stdout after 3 seconds. You can think of after() as the tkinter version of time.sleep(), but it also adds the ability to call a function after the sleep has finished.
You could use this functionality to improve user experience. By adding a Python sleep() call, you can make the application appear to load faster and then start some longer-running process after it‚Äôs up. That way, the user won‚Äôt have to wait for the application to open.
  Remove adsSleeping in wxPython
There are two major differences between wxPython and Tkinter:

wxPython has many more widgets.
wxPython aims to look and feel native on all platforms.

The wxPython framework is not included with Python, so you‚Äôll need to install it yourself. If you‚Äôre not familiar with wxPython, then check out How to Build a Python GUI Application With wxPython.
In wxPython, you can use wx.CallLater() to add a Python sleep() call:
import wx

class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(parent=None, title='Hello World')
        wx.CallLater(4000, self.delayed)
        self.Show()

    def delayed(self):
        print('I was delayed')

if __name__ == '__main__':
    app = wx.App()
    frame = MyFrame()
    app.MainLoop()

Here, you subclass wx.Frame directly and then call wx.CallLater(). This function takes the same parameters as Tkinter‚Äôs after():

The number of milliseconds to sleep
The method to call when the sleep is finished

When you run this code, you should see a small blank window appear without any widgets. After 4 seconds, you‚Äôll see the string 'I was delayed' printed to stdout.
One of the benefits of using wx.CallLater() is that it‚Äôs thread-safe. You can use this method from within a thread to call a function that‚Äôs in the main wxPython application.
Conclusion
With this tutorial, you‚Äôve gained a valuable new technique to add to your Python toolbox! You know how to add delays to pace your applications and prevent them from using up system resources. You can even use Python sleep() calls to help your GUI code redraw more effectively. This will make the user experience much better for your customers!
To recap, you‚Äôve learned how to add Python sleep() calls with the following tools:

time.sleep()
Decorators
Threads
asyncio
Tkinter
wxPython

Now you can take what you‚Äôve learned and start putting your code to sleep!



Mark as Completed





Table of Contents


Adding a Python sleep() Call With time.sleep()
Adding a Python sleep() Call With Decorators
Adding a Python sleep() Call With Threads
Using time.sleep()
Using Event.wait()


Adding a Python sleep() Call With Async IO
Adding a Python sleep() Call With GUIs
Sleeping in Tkinter
Sleeping in wxPython


Conclusion





Adding a Python sleep() Call With time.sleep()
Adding a Python sleep() Call With Decorators
Adding a Python sleep() Call With Threads
Using time.sleep()
Using Event.wait()


Adding a Python sleep() Call With Async IO
Adding a Python sleep() Call With GUIs
Sleeping in Tkinter
Sleeping in wxPython


Conclusion







   Remove ads







Free Bonus: Get our free "The Power of Python Decorators" guide that shows you 3 advanced decorator patterns and techniques you can use to write to cleaner and more Pythonic programs.
  Remove ads



>>>>>> import time
>>> time.sleep(3) # Sleep for 3 seconds


Note: In Python 3.5, the core developers changed the behavior of time.sleep() slightly. The new Python sleep() system call will last at least the number of seconds you‚Äôve specified, even if the sleep is interrupted by a signal. This does not apply if the signal itself raises an exception, however.

$ python3 -m timeit -n 3 "import time; time.sleep(3)"
3 loops, best of 3: 3 sec per loop

import time
import urllib.request
import urllib.error

def uptime_bot(url):
    while True:
        try:
            conn = urllib.request.urlopen(url)
        except urllib.error.HTTPError as e:
            # Email admin / log
            print(f'HTTPError: {e.code} for {url}')
        except urllib.error.URLError as e:
            # Email admin / log
            print(f'URLError: {e.code} for {url}')
        else:
            # Website is up
            print(f'{url} is up')
        time.sleep(60)

if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)

HTTPError: 404 for http://www.google.com/py

import time
import urllib.request
import urllib.error

def sleep(timeout, retry=3):
    def the_real_decorator(function):
        def wrapper(*args, **kwargs):
            retries = 0
            while retries < retry:
                try:
                    value = function(*args, **kwargs)
                    if value is None:
                        return
                except:
                    print(f'Sleeping for {timeout} seconds')
                    time.sleep(timeout)
                    retries += 1
        return wrapper
    return the_real_decorator

@sleep(3)
def uptime_bot(url):
    try:
        conn = urllib.request.urlopen(url)
    except urllib.error.HTTPError as e:
        # Email admin / log
        print(f'HTTPError: {e.code} for {url}')
        # Re-raise the exception for the decorator
        raise urllib.error.HTTPError
    except urllib.error.URLError as e:
        # Email admin / log
        print(f'URLError: {e.code} for {url}')
        # Re-raise the exception for the decorator
        raise urllib.error.URLError
    else:
        # Website is up
        print(f'{url} is up')

if __name__ == '__main__':
    url = 'http://www.google.com/py'
    uptime_bot(url)


Note: If you‚Äôd like to brush up on exception handling in Python, then check out Python Exceptions: An Introduction.

  Remove ads




Note: Threads are a method of doing concurrency in Python. You can run multiple threads at once to increase your application‚Äôs throughput. If you‚Äôre not familiar with threads in Python, then check out An Intro to Threading in Python.

import logging
import threading
import time

def worker(arg):
    while not arg["stop"]:
        logging.debug("worker thread checking in")
        time.sleep(1)

def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(relativeCreated)6d %(threadName)s %(message)s"
    )
    info = {"stop": False}
    thread = threading.Thread(target=worker, args=(info,))
    thread_two = threading.Thread(target=worker, args=(info,))
    thread.start()
    thread_two.start()

    while True:
        try:
            logging.debug("Checking in from main thread")
            time.sleep(0.75)
        except KeyboardInterrupt:
            info["stop"] = True
            logging.debug('Stopping')
            break
    thread.join()
    thread_two.join()

if __name__ == "__main__":
    main()

 0 Thread-1 worker thread checking in
 1 Thread-2 worker thread checking in
 1 MainThread Checking in from main thread
752 MainThread Checking in from main thread
1001 Thread-1 worker thread checking in
1001 Thread-2 worker thread checking in
1502 MainThread Checking in from main thread
2003 Thread-1 worker thread checking in
2003 Thread-2 worker thread checking in
2253 MainThread Checking in from main thread
3005 Thread-1 worker thread checking in
3005 MainThread Checking in from main thread
3005 Thread-2 worker thread checking in

import logging
import threading

def worker(event):
    while not event.isSet():
        logging.debug("worker thread checking in")
        event.wait(1)

def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(relativeCreated)6d %(threadName)s %(message)s"
    )
    event = threading.Event()

    thread = threading.Thread(target=worker, args=(event,))
    thread_two = threading.Thread(target=worker, args=(event,))
    thread.start()
    thread_two.start()

    while not event.isSet():
        try:
            logging.debug("Checking in from main thread")
            event.wait(0.75)
        except KeyboardInterrupt:
            event.set()
            break

if __name__ == "__main__":
    main()


Note: If you‚Äôd like to learn more about dictionaries, then check out Dictionaries in Python.

  Remove ads



import asyncio

async def main():
    print('Hello ...')
    await asyncio.sleep(1)
    print('... World!')

# Python 3.7+
asyncio.run(main())

import asyncio
import time

async def output(sleep, text):
    await asyncio.sleep(sleep)
    print(text)

async def main():
    print(f"Started: {time.strftime('%X')}")
    await output(1, 'First')
    await output(2, 'Second')
    await output(3, 'Third')
    print(f"Ended: {time.strftime('%X')}")

# Python 3.7+
asyncio.run(main())

import asyncio
import time

async def output(text, sleep):
    while sleep > 0:
        await asyncio.sleep(1)
        print(f'{text} counter: {sleep} seconds')
        sleep -= 1

async def main():
    task_1 = asyncio.create_task(output('First', 1))
    task_2 = asyncio.create_task(output('Second', 2))
    task_3 = asyncio.create_task(output('Third', 3))
    print(f"Started: {time.strftime('%X')}")
    await task_1
    await task_2
    await task_3                                 
    print(f"Ended: {time.strftime('%X')}")

if __name__ == '__main__':
    asyncio.run(main())

import tkinter
import time

class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        b = tkinter.Button(text="click me", command=self.delayed)
        b.pack()

    def delayed(self):
        time.sleep(3)

if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()

import tkinter

class MyApp:
    def __init__(self, parent):
        self.root = parent
        self.root.geometry("400x400")
        self.frame = tkinter.Frame(parent)
        self.frame.pack()
        self.root.after(3000, self.delayed)

    def delayed(self):
        print('I was delayed')

if __name__ == "__main__":
    root = tkinter.Tk()
    app = MyApp(root)
    root.mainloop()

  Remove ads



import wx

class MyFrame(wx.Frame):
    def __init__(self):
        super().__init__(parent=None, title='Hello World')
        wx.CallLater(4000, self.delayed)
        self.Show()

    def delayed(self):
        print('I was delayed')

if __name__ == '__main__':
    app = wx.App()
    frame = MyFrame()
    app.MainLoop()



Mark as Completed




Mark as Completed



üêç Python Tricks üíå




Get a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team.












Send Me Python Tricks ¬ª









Get a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team.












Send Me Python Tricks ¬ª







Get a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team.












Send Me Python Tricks ¬ª





Get a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team.






Get a short & sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. Curated by the Real Python team.











Send Me Python Tricks ¬ª






About Mike Driscoll








Mike has been programming in Python for over a decade and loves writing about Python!
¬ª More about Mike








Each tutorial at Real Python is created by a team of developers so that it meets our high quality standards. The team members who worked on this tutorial are:






Aldren





Geir Arne





Jaya







Jon





Joanna















Mike has been programming in Python for over a decade and loves writing about Python!
¬ª More about Mike











Mike has been programming in Python for over a decade and loves writing about Python!
¬ª More about Mike









Mike has been programming in Python for over a decade and loves writing about Python!
¬ª More about Mike







Mike has been programming in Python for over a decade and loves writing about Python!
¬ª More about Mike




Each tutorial at Real Python is created by a team of developers so that it meets our high quality standards. The team members who worked on this tutorial are:






Aldren





Geir Arne





Jaya







Jon





Joanna








Each tutorial at Real Python is created by a team of developers so that it meets our high quality standards. The team members who worked on this tutorial are:






Aldren





Geir Arne





Jaya







Jon





Joanna






Each tutorial at Real Python is created by a team of developers so that it meets our high quality standards. The team members who worked on this tutorial are:






Aldren





Geir Arne





Jaya






Aldren





Geir Arne





Jaya






Jon





Joanna








Jon





Joanna





Master Real-World Python Skills With Unlimited Access to Real¬†Python

Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert¬†Pythonistas:
Level Up Your Python Skills ¬ª


Master Real-World Python SkillsWith Unlimited Access to Real¬†Python

Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Level Up Your Python Skills ¬ª



Master Real-World Python Skills With Unlimited Access to Real¬†Python

Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert¬†Pythonistas:
Level Up Your Python Skills ¬ª


Master Real-World Python SkillsWith Unlimited Access to Real¬†Python

Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Level Up Your Python Skills ¬ª


What Do You Think?


Tweet
Share
Email




Real Python Comment Policy: The most useful comments are those written with the goal of learning from or helping out other readers‚Äîafter reading the whole article and all the earlier comments. Complaints and insults generally won‚Äôt make the cut here.

What‚Äôs your #1 takeaway or favorite thing you learned? How are you going to put your newfound skills to use? Leave a comment below and let us know.






Tweet
Share
Email




Real Python Comment Policy: The most useful comments are those written with the goal of learning from or helping out other readers‚Äîafter reading the whole article and all the earlier comments. Complaints and insults generally won‚Äôt make the cut here.

What‚Äôs your #1 takeaway or favorite thing you learned? How are you going to put your newfound skills to use? Leave a comment below and let us know.




Real Python Comment Policy: The most useful comments are those written with the goal of learning from or helping out other readers‚Äîafter reading the whole article and all the earlier comments. Complaints and insults generally won‚Äôt make the cut here.




Keep Learning

Related Tutorial Categories:
intermediate
python




Related Tutorial Categories:
intermediate
python







Master Real-World Python Skills With Unlimited Access to Real Python
Already a member? Sign-In





Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Unlock All Content ¬ª



Close








Master Real-World Python Skills With Unlimited Access to Real Python
Already a member? Sign-In





Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Unlock All Content ¬ª



Close






Master Real-World Python Skills With Unlimited Access to Real Python
Already a member? Sign-In





Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Unlock All Content ¬ª



Close




Master Real-World Python Skills With Unlimited Access to Real Python
Already a member? Sign-In



Master Real-World Python Skills With Unlimited Access to Real Python
Already a member? Sign-In




Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Unlock All Content ¬ª




Join us and get access to hundreds of tutorials, hands-on video courses, and a community of expert Pythonistas:
Unlock All Content ¬ª


Close




‚Äî FREE Email Series ‚Äî
üêç Python Tricks üíå







Get Python Tricks ¬ª
üîí No spam. Unsubscribe any time.



‚Äî FREE Email Series ‚Äî
üêç Python Tricks üíå








All Tutorial Topics
advanced
api
basics
best-practices
community
databases
data-science
devops
django
docker
flask
front-end
gui
intermediate
machine-learning
projects
python
testing
tools
web-dev
web-scraping















Table of Contents


Adding a Python sleep() Call With time.sleep()
Adding a Python sleep() Call With Decorators
Adding a Python sleep() Call With Threads
Using time.sleep()
Using Event.wait()


Adding a Python sleep() Call With Async IO
Adding a Python sleep() Call With GUIs
Sleeping in Tkinter
Sleeping in wxPython


Conclusion





Mark as Completed





Tweet
Share
Email










Table of Contents


Adding a Python sleep() Call With time.sleep()
Adding a Python sleep() Call With Decorators
Adding a Python sleep() Call With Threads
Using time.sleep()
Using Event.wait()


Adding a Python sleep() Call With Async IO
Adding a Python sleep() Call With GUIs
Sleeping in Tkinter
Sleeping in wxPython


Conclusion





Adding a Python sleep() Call With time.sleep()
Adding a Python sleep() Call With Decorators
Adding a Python sleep() Call With Threads
Using time.sleep()
Using Event.wait()


Adding a Python sleep() Call With Async IO
Adding a Python sleep() Call With GUIs
Sleeping in Tkinter
Sleeping in wxPython


Conclusion




Mark as Completed




Mark as Completed




Tweet
Share
Email


























Almost there! Complete this form and click the button below to gain instant access:




√ó









The Power of Python Decorators: Advanced Patterns & Techniques (PDF Guide)






Get the Python Decorators Guide ¬ª



















Almost there! Complete this form and click the button below to gain instant access:




√ó









The Power of Python Decorators: Advanced Patterns & Techniques (PDF Guide)






Get the Python Decorators Guide ¬ª

















Almost there! Complete this form and click the button below to gain instant access:




√ó









The Power of Python Decorators: Advanced Patterns & Techniques (PDF Guide)






Get the Python Decorators Guide ¬ª















Almost there! Complete this form and click the button below to gain instant access:




√ó










Almost there! Complete this form and click the button below to gain instant access:










Almost there! Complete this form and click the button below to gain instant access:












Almost there! Complete this form and click the button below to gain instant access:








The Power of Python Decorators: Advanced Patterns & Techniques (PDF Guide)






Get the Python Decorators Guide ¬ª











The Power of Python Decorators: Advanced Patterns & Techniques (PDF Guide)






Get the Python Decorators Guide ¬ª









The Power of Python Decorators: Advanced Patterns & Techniques (PDF Guide)






Get the Python Decorators Guide ¬ª







The Power of Python Decorators: Advanced Patterns & Techniques (PDF Guide)






Get the Python Decorators Guide ¬ª






¬© 2012‚Äì2021 Real Python¬†‚ãÖ Newsletter¬†‚ãÖ Podcast¬†‚ãÖ YouTube¬†‚ãÖ Twitter¬†‚ãÖ Facebook¬†‚ãÖ Instagram¬†‚ãÖ Python¬†Tutorials¬†‚ãÖ Search¬†‚ãÖ Privacy Policy¬†‚ãÖ Energy Policy¬†‚ãÖ Advertise¬†‚ãÖ Contact‚ù§Ô∏è Happy Pythoning!

